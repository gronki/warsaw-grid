
// This defines the sizes and breakpoints. Any sizes can be defined here, as long
// as following conditions are satisfied:
// 1. the smallest size is named "sm" and its lower boundary is 0px
// 2. the upper boundary of the largest size is named "infinity"
$sizes:      sm,      md,       lg,      xl;
$brkpnt: 0px,   638px,   838px,   1078px,  infinity;

// this can be changed to any values that suit you
$gutter:    4%;
$grid-base: 12;

// we dont want our elements to have any margins or borders by default
div.container, div.row, div.col {
    box-sizing: border-box !important;
    margin: 0px;
    border: none;
}

// this mixin allows you to define style only for a given size
@mixin respond ($size: sm) {
    @for $i from 1 through length($sizes) {
        $sz: nth($sizes,$i);
        @if $size == $sz {
            $b-lo: nth($brkpnt,$i);
            $b-hi: nth($brkpnt,$i+1);
            @if $b-lo == 0px {
                // smallest devices
                @media  (max-width: $b-hi - 1px) { @content; }
            } @elseif $b-hi == infinity {
                // largest devices
                @media  (min-width: $b-lo) { @content; }
            } @else {
                // medium devices
                @media  (min-width: $b-lo)
                and (max-width: $b-hi - 1px) { @content; }
            }
        }
    }
}

// this mixin allows you to define a style for given-or-larger devices
// which is useful during the mobile-first approach
@mixin breakpoint($size: sm) {
    @for $i from 1 through length($sizes) {
        $sz: nth($sizes,$i);
        @if $size == $sz {
            $b-lo: nth($brkpnt,$i);
            @if $b-lo == 0px {
                @content;
            } @else {
                @media  (min-width: $b-lo) { @content; }
            }
        }
    }
}

// the container class wraps all the content, centers it and gives it size
div.container {
    display: block;
    margin: 0px $gutter/2;
    @include breakpoint(md) {
        margin: 0px auto;
    }
    @for $i from 2 through length($sizes) {
        $sz: nth($sizes,$i);
        $bp: nth($brkpnt,$i);
        @include breakpoint($sz) {
            max-width: $bp * 0.97;
        }
    }
    padding: 0px;
    div.row {
        display: block;
        margin-top: $gutter / 2;
        margin-bottom: $gutter / 2;
        // negative margins allow us to keep margins consistent in nested columns
        // and also with content not wrapped in rows/columns
        margin-left: -$gutter/2 !important;
        margin-right: -$gutter/2  !important;
        div.col {
            display: block;
            float: left;
            margin: 0px $gutter / 2;
        }
        // "the clear fix"
        &::after {
            content: "";
            display: table;
            border: none;
            height: 0px;
            width: 0px;
            margin: 0px;
            padding: 0px;
            clear: both;
        }
    }
}
div.col {
    // by default, the column has 100% width (minus gutter)
    width: 100% - $gutter;
}

// this should never be used! internal helper
@mixin column-base($g) {
    @if $g > $grid-base {
        $g: $grid-base;
    }
    width: percentage($g / $grid-base) - $gutter;
}

// this causes the given div to behave like a column of width $g
// starting from size $bp. to force column on all sizes, use "all"
@mixin column($bp,$g) {
    display: block;
    float: left;
    width: 100% - $gutter;
    margin: 0px $gutter / 2;
    @if $bp == all {
        @include column-base($g);
    } @else {
        @include breakpoint($bp) {
            @include column-base($g);
        }
    }
}

.clearfix {
    clear: both;
}
